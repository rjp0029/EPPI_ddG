/* Created by the Pantazes Lab at Auburn University.
 *
 * This file implements the protein writing method. */

// This file is supposed to be loaded by Methods.h
#ifndef Methods_Loading_Status
#error General Methods must be included by Methods.h
#endif

// Implement the function
void METHODS::write_proteins (vector<string> * command,
                              vector<PROT::Protein>& proteins,
                              const string& path,
                              ofstream& summary) {
    // Validate that the command has 1 entry
    if (command->size() != 1) {
        string error = "Algorithm Error: METHODS::write_protein called with "
                       "an invalid command\n";
        throw PANTZ_error (error);}
    // Get the command
    string info = (*command)[0];
    // Split it into pieces
    vector<string> parts; Text::split(parts, info);
    // Get pointers to the proteins
    vector<PROT::Protein *> prots;
    // There are two collection methods for the pointers. Use this boolean flag
    // to see if the first is implemented
    bool collectionDone = false;
    // The first option is to list all of the proteins
    if ((parts.size() == 1) && (parts[0].size() == 3)) {
        // convert the word into lowercase letters
        string word = parts[0]; Text::lower(word);
        if (word == "all") {
            // Indicate that the method is done
            collectionDone = true;
            // Store pointers to all of the proteins
            for(size_t i=0; i<proteins.size(); ++i) {
                prots.push_back(&(proteins[i]));}}}
    // If the list wasn't filled in with all of the proteins
    if (!collectionDone) {
        // Go through the listed proteins
        for(size_t i=0; i<parts.size(); ++i) {
            // Validate that it is a protein name
            if (parts[i].size() != 1) {
                string error = "Invalid protein name: " + parts[i] + "\n"
                       "This error was thrown in METHODS::write_proteins\n";
                throw PANTZ_error (error);}
            // Get the charater of the protein's name
            char L = parts[i][0];
            // Find the protein
            bool proteinFound = false;
            for(size_t j=0; j<proteins.size(); ++j) {
                if (proteins[j].name() == L) {
                    proteinFound = true;
                    prots.push_back(&(proteins[j]));}
                    break;}
            // If the protein wasn't found, throw an error
            if (!proteinFound) {
                string error = "No protein '" + parts[i] + "' was found to "
                               "write to a file.\n";
                throw PANTZ_error (error);}}}
    // If no proteins were found
    if (prots.size() == 0) {
        string error = "Algorithm Error: No proteins found for writing.\n";
        throw PANTZ_error (error);}
    // Create the appropriate header for the file
    string when = METHODS::time_stamp(); Text::upper(when);
    string text = "HEADER    CREATED ON " + when + "\nEXPDTA    "
                  "THEORETICAL MODEL\nREMARK 220 REMARK: MODEL GENERATED BY "
                  "PANTZ SOFTWARE\n";
    // Make a file name
    string fileName = path + "_protein";
    if (prots.size() > 1) {fileName += "s";}
    for(size_t i=0; i<prots.size(); ++i) {
        fileName += "_";
        fileName += prots[i]->name();}
    fileName += ".pdb";
    // Open the file
    ofstream output; output.open(fileName.c_str());
    // If that failed, throw an error
    if (!output.is_open()) {
        string error = "Failed to write proteins to this file: " 
                     + fileName + "\n";
        throw PANTZ_error(error);}
    // Write the header to the file
    output << text;
    // Write the proteins, using external numbering. Renumber the Atoms so they
    // are sequential starting from 1 in this output file
    long atomNum = 1;
    for(size_t i=0; i<prots.size(); ++i) {
        atomNum = prots[i]->renumber_atoms(atomNum);
        output << prots[i]->str(false);}
    // End the PDB file
    output << "END\n";
    // Close the file
    output.close();
    // If the summary file exists, update it
    if (summary.is_open()) {
        text = "Proteins output on " + METHODS::time_stamp() + "\n"
               "Output Proteins:";
        for(size_t i=0; i<prots.size(); ++i) {
            text += " ";
            text += prots[i]->name();}
        text += "\n";
        summary << text << endl;}
}
