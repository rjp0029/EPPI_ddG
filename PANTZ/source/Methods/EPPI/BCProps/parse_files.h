/* created by the PROTEINPANT(z) lab at Auburn University 2025
    This is the file that implements the methods to parse the per residue
    rosetta file and the rosetta interface score file and the features.txt 
    file all of which get generated by the calcuate_eppi_features function
*/

// preproccessor directives to make sure the parse files is included by the
// correct file
#ifndef EPPI_BCProps_Loading_Status
#error parse_files.h must be included by BCProps.h
#endif

// include the necessary libraries
#include <map>

// this is a function to parse the per res_file and return a map of pairwise energies 
map<string, double> EPPI::BCProps::parse_per_res_file(string per_res_rosetta_file) {
    map<string, double> energy_map;
    ifstream f(per_res_rosetta_file);
    string line;
    while (getline(f, line)) {
        // split the lines on tab
        vector<string> words;
        Text::split(words, line);
        if (words[1] == "pose_id") {
            continue;
        }
        string key = Text::split(words[3], ':')[0] + words[4] + " " + Text::split(words[6], ':')[0] + words[7];
        double energy = stof(words[words.size() - 2]);
        energy_map[key] = energy;
    }
    return energy_map;
}

// this is a function to parse the ria file and return dg_separated, bsa, and sc values
vector<double> EPPI::BCProps::parse_ria_file(string ria_file) {
    vector<double> ria_values;
    ifstream f(ria_file);
    string line;
    while (getline(f, line)) {
        if (line.find("SEQUENCE:") != string::npos || line.find("SCORE: total_score") != string::npos) {
            continue;
        } else {
            vector<string> words;
            Text::split(words, line);
            double dg_separated = stof(words[5]);
            double bsa = stof(words[8]);
            double sc = stof(words[words.size() - 7]);
            ria_values.push_back(dg_separated);
            ria_values.push_back(bsa);
            ria_values.push_back(sc);
        }
    }
    return ria_values;
}

// this is the function to parse the features.txt file and get the 
// hydrogen bonds, salt bridges, and hydrophobic interactions
void EPPI::BCProps::parse_eppi_file(string eppi_file, vector<EPPI::HydrogenBond*> &hydrogen_bonds, 
    vector<EPPI::SaltBridge*> &salt_bridges, vector<EPPI::Hydrophobic*> &hydrophobic_interactions) {
    ifstream f(eppi_file);
    string line;
    while (getline(f, line)) {
        if (line.find("Hydrogen Bond") != string::npos) {
            hydrogen_bonds.push_back(new EPPI::HydrogenBond(line));
        } else if (line.find("Salt Bridge") != string::npos) {
            salt_bridges.push_back(new EPPI::SaltBridge(line));
        } else if (line.find("Hydrophobic Interaction") != string::npos) {
            hydrophobic_interactions.push_back(new EPPI::Hydrophobic(line));
        } else {
            cout<<"Error: unknown interaction type"<<endl;
            // exit the program
            exit(1);
        }
    }
}

// write base features to csv file
void EPPI::BCProps::append_to_csv(string& csv_file) {
    // append to the csv file
    ofstream f(csv_file, ios::app);
    f<<m_name<<",";
    for (size_t i=0; i<m_primaryFeatures.size(); ++i) {
        f<<m_primaryFeatures[i]<<",";
    }
    for (size_t i=0; i<m_derivedFeatures.size(); ++i) {
        f<<m_derivedFeatures[i]<<",";
    }
    f<<endl;
    f.close();
}